//! Message bus for inter-component communication
//!
//! Implements a lock‑free, zero‑copy channel using crossbeam.

#![allow(dead_code)] // For demonstration, we leave unused variants until they are used in the pipeline.

use bytes::Bytes;
use crossbeam_channel::{bounded, Receiver, Sender};

/// Enumeration of all events passing through the system.
/// Some variants will be constructed as the pipeline evolves.
#[derive(Debug)]
pub enum Event {
    /// A network packet captured from live or simulation mode.
    Packet { timestamp: u64, data: Bytes },
    /// An alert generated by the detection engine.
    Alert {
        rule_id: String,
        packet: Bytes,
        severity: AlertLevel,
    },
    /// A prevention action event.
    Prevention { action: PreventionAction },
    /// A snapshot event, containing the serialized system state.
    Snapshot { data: Bytes, checksum: [u8; 32] },
}

/// Alert levels for generated alerts.
#[derive(Debug, Clone)]
pub enum AlertLevel {
    Info,
    Warn,
    Critical,
}

/// Prevention actions, for example, blocking a source.
#[derive(Debug, Clone)]
pub enum PreventionAction {
    Block,
    Throttle,
}

/// A simple message bus using a bounded channel.
pub struct MessageBus {
    pub tx: Sender<Event>,
    pub rx: Receiver<Event>,
}

impl MessageBus {
    /// Create a new message bus with the given capacity.
    pub fn new(capacity: usize) -> Self {
        let (tx, rx) = bounded(capacity);
        Self { tx, rx }
    }

    /// Send an event, propagating errors.
    #[inline(always)]
    pub fn send(&self, event: Event) -> anyhow::Result<()> {
        self.tx.send(event)?;
        Ok(())
    }
}
